SOFE3950U Operating Systems Lab 4 Design Report


















Done by:	Malek Mustapha-Abdullah		100541476
Clayton Cheung			100539921
Dominick Mancini			100517944
Scott McLean				100379538
Neil Ramdath				
Date:		November 27, 2015
Professor:	Dr. Khaleed A. Hafeez 
Memory Allocation Algorithms
	In our HOST dispatcher shell, we have a hypothetical memory resource of a maximum of 1024MB, which is represented by an array max_memory of size 1024. In the array, free memory is represented by zeros, while used memory is represented by ones. The alloc_mem function in the utility class accepts two arguments, res the resource being used and size, the size of the process that is entered. Firstly, the function calculates the index at which the process will be allocating resources. The program does this by checking where the next zero is in the max_memory array, since that is where there is available memory. The loop is iterated until the next zero is found and for every iteration the start_index variable is increased until the free memory is found. Therefore, when the loop is finished, the start_index variable holds the location of the first available zero in the max_memory array. Secondly, the function loops through the max_memory array in order to calculate the available memory. This is done by looping through the array and for every zero that is counted in the array, the free_space variable is increased by one until no more zeroes are found. After the amount of free space is calculated, a check is made to make sure the amount of free space is greater than 64MB, since one of the requirements is that there should always be 64MB of free space for real time processes.  Lastly after the start index is found and the amount of free space is calculated, a loop is executed which allocates the total amount of memory that was needed by the process. This is done by changing the zeroes in the max_memory array into ones.
Data Structures
	The data structure we used in our HOST dispatcher shell is a first-in, first-out queue. To implement the queue, we use two functions push and pop. The push function is used to queue a process and when the process is ready to be dispatched it is done so by calling the pop function. 
Overall Structure
	In the main function of our HOST dispatcher shell, all of the queues that are required are declared as instances of the struct node_t. After the queues are declared, the dispatch queue is populated with the data from the dispatch list using the load_dispatch function. According to the data from the dispatch list relating to the priority of each process, the different queues are pushed onto the queue. Since the queue is operating on a first-in, first-out basis, the process with the highest priority will be pushed first and so on. Since the processes are now in the queue and ready to be run, the function _runprocess is called for each process and the process is executed. In the _runprocess function, the process is popped from the queue, and the amount of memory needed for the process is allocated if enough memory is available. Every process is executed when there is available memory until every process is run to completion.
Design Rationale
	Such a multilevel dispatching scheme would be used in order to determine which processes are the highest of priority, and how much memory each process would need for execution. In comparison to a real operating system, it uses a similar first-in, first-out queue for processes according to priority, as well as memory allocation system which checks if enough memory is available for a process to be executed. Some shortcomings for such a scheme, is that if there was a lot of processes to be handled, the system might be in-efficient in trying to determine how much memory is needed, and allocating that memory. An improvement would be to use multi-threading so more than one process can be executed at a time.

